# Refer to the Scala style guide at:
#   http://docs.scala-lang.org/style/
#
# TODO: Akka actor snippets:
#   - actor snippet with companion object with props factory method
#   - receive method
#   - watch, supervision strategies
#   - some Akka IO snippets, maybe

# See http://www.scala-lang.org/node/166
snippet '^#!' "Scala shell script shebang" r
#!/usr/bin/env scala

endsnippet


snippet "im(port)?" "Import, with optional enumerations" br
import ${1:packages}${2:.${3:\{ ${4:Class, AnotherClass} \}}${5:._}}
endsnippet


snippet pri "private Visibility"
private ${1:val}
endsnippet


snippet pris "Scoped private Visibility"
private[${1:scope}] ${2:val}
endsnippet


snippet pro "protected Visibility"
protected ${1:val}
endsnippet


snippet pros "Scoped protected Visibility"
protected[${1:scope}] ${2:val}
endsnippet


snippet self "Self Type Annotation"
${1:self}: ${2:Type} =>
endsnippet


# This avoids matching some other snippets ending in "{"
# TODO: try to make this work if there's already text after the { ?
snippet "(?<!(for|kup) ){" "Expand inline block" wr
{ ${1:${VISUAL}} }
endsnippet


snippet } "Expand multi-line block" w
{
	${1:${VISUAL}}
}
endsnippet


snippet val "Value"
val ${1:name}${2:: ${3:T}} = ${4:value}
endsnippet


snippet var "Variable"
var ${1:name}${2:: ${3:T}} = ${4:value}
endsnippet


snippet l "Anonymous Function (mnemonic: lambda)" w
${1:(${2:x: Int})} => ${3:x + 1}
endsnippet


snippet def "Method Declaration"
def ${1:name}${2:(${3:arg})}${4:: ${5:ReturnType}} = ${6:\{
	${7:${VISUAL}}
\}}
endsnippet


snippet arg "Method Arguments" i
${1:a}: ${2:T}${3:, arg}
endsnippet


snippet vararg "Var arg" i
${1:args}: ${2:T}*
endsnippet


# TODO: Odersky considers this syntax a misfeature, now strongly frowned upon;
# This snippet could still be useful with equals sign and Unit return?
snippet proc "Procedure (pure side-effect function)"
def ${1:name}(${2:arg}$3) ${4:\{
	${5:${VISUAL}}
\}}
endsnippet


snippet class "Class Declaration"
class ${1:Person}${2:(${3:arg})}${4: extends ${5:Trait}${6: with ${7:Another}}} {
	$0
}
endsnippet


snippet 'obj(ect)?' "Object Declaration" br
object ${1:Name}${2: extends ${3:App}${4: with ${5:Mixin}}} {
	$0
}
endsnippet


snippet trait "Trait Declaration"
trait ${1:Name}${2: extends ${3:Other}${4: with ${5:Another}}} {
	$0
}
endsnippet


# "case" is overloaded with pattern matching, so use a completely different mnemonic
snippet adt "Case Class (Algebraic Data Type)"
case class ${1:Name}(${2:arg}$3)
endsnippet


snippet extends "extends ... with"
extends ${1:Trait}${2: with ${3:Another}}
endsnippet


snippet with "with ..."
with ${1:That}${2: with}$3
endsnippet


snippet if "If Block/Inline"
if (${1:condition}) ${2:\{
	${3:${VISUAL}}
\}}
endsnippet


snippet else "Else Block/Inline"
else ${2:\{
	$3
\}}
endsnippet


snippet ife "If/Else Block/Inline"
if (${1:condition}) ${2:\{
	${3:${VISUAL}}
\}} else ${4:\{
	$5
\}}
endsnippet


snippet elif "else if Block"
else if (${1:condition}) ${2:\{
	$3
\}}
endsnippet


snippet match "Match Block"
match {
	case ${1:pattern} => ${2:expression}$3
}
endsnippet


snippet case "Case Clause"
case ${1:_} => ${2:expression}
endsnippet


# Type {} over the yield placeholder for imperative.
snippet for "Sequence Comprehension Inline / Imperative for"
for (${1:i} <- ${2:0 to 10}) ${3:yield $4}
endsnippet


snippet "for {" "Sequence Comprehension Block"
for {
	${1:i} <- ${2:0 until n}
} yield $0
endsnippet


snippet kv "Key/Value Literal (Map)" w
${1:key} -> ${2:value}${3:, kv}
endsnippet


snippet kvs "Key/Value Literal, String-Keyed (Map)" w
"${1:key}" -> ${2:value}${3:, kvs}
endsnippet


snippet Map "Map[K, V]"
Map[${1:K}, ${2:V}](${3:kv}$4)
endsnippet


snippet main "Application Object main Method Declaration" b
def main(args: Array[String]) {
	${0:${VISUAL}}
}
endsnippet


snippet "tos(tr)?" "toString Declaration" br
override def toString = ${1:\{
	$2
\}}
endsnippet


# TODO: try/catch, Try
snippet throw "throw Exception"
throw new ${1:Exception}${2:("${3:message}")}
endsnippet

